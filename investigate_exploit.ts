
import Database from 'better-sqlite3';
import path from 'path';
import { Connection, PublicKey } from '@solana/web3.js';
import { getAssociatedTokenAddress } from '@solana/spl-token';
import { SKR_MINT, RPC_URL, WALLET_KEYPAIR } from './config';

const DB_PATH = path.join(__dirname, 'flywheel.db');
const db = new Database(DB_PATH, { readonly: true });

async function investigate() {
    console.log("--- EXPLOIT INVESTIGATION REPORT ---");
    console.log(`Time: ${new Date().toISOString()}`);

    // 1. Analyze Claims Table
    console.log("\n1. Analyzing Claims History...");
    try {
        const claims = db.prepare('SELECT * FROM claims ORDER BY timestamp DESC').all();
        console.log(`Total Claims Recorded: ${claims.length}`);

        // Group by Epoch and Address
        const claimsPerEpochUser: Record<string, number> = {};
        const claimsPerEpoch: Record<number, number> = {};

        claims.forEach((c: any) => {
            const key = `${c.epochId}:${c.address}`;
            if (!claimsPerEpochUser[key]) claimsPerEpochUser[key] = 0;
            claimsPerEpochUser[key]++;

            if (!claimsPerEpoch[c.epochId]) claimsPerEpoch[c.epochId] = 0;
            claimsPerEpoch[c.epochId] += c.amount;
        });

        // Find Suspicious Duplicates (Race Condition Signatures)
        const suspicious = Object.entries(claimsPerEpochUser).filter(([_, count]) => count > 1);

        if (suspicious.length > 0) {
            console.log(`\nðŸš¨ SUSPICIOUS ACTIVITY DETECTED: ${suspicious.length} users claimed multiple times in a single epoch!`);
            suspicious.forEach(([key, count]) => {
                const [epoch, addr] = key.split(':');
                console.log(`- Epoch ${epoch}: User ${addr} claimed ${count} times.`);

                // Detail the timestamps for this user/epoch
                const userClaims = claims.filter((c: any) => c.epochId == epoch && c.address == addr);
                userClaims.forEach((uc: any) => {
                    console.log(`   > ID: ${uc.id}, Amount: ${uc.amount}, Time: ${new Date(uc.timestamp).toISOString()}`);
                });
            });
        } else {
            console.log("\nâœ… No duplicate claims detected per user/epoch in DB.");
        }

        // Dump Stats
        console.log("\n=== SYSTEM STATS ===");
        const stats = db.prepare('SELECT * FROM stats').all();
        stats.forEach((s: any) => console.log(`${s.key}: ${s.value}`));

        // Dump Logs
        console.log("\n=== RECENT LOGS ===");
        const logs = db.prepare('SELECT * FROM logs ORDER BY id DESC LIMIT 20').all();
        logs.forEach((l: any) => console.log(`[${l.timestamp}] ${l.message}`));

        // 2. Analyize Total Outflows
        console.log("\n2. Total Outflows per Epoch:");
        Object.entries(claimsPerEpoch).forEach(([epoch, total]) => {
            console.log(`- Epoch ${epoch}: ${total.toFixed(2)} SKR distributed`);
        });

    } catch (e: any) {
        console.error("DB Error:", e.message);
    }

    // 3. Check Current Vault Balance
    console.log("\n3. Current On-Chain Vault Balance...");
    try {
        const connection = new Connection(RPC_URL);
        const vaultPubkey = WALLET_KEYPAIR.publicKey;
        const skrMint = new PublicKey(SKR_MINT);

        // We need to know the program ID to get the correct ATA, assuming standard for query
        // Simply querying token accounts by owner is safer to find WHERE the money is
        const accounts = await connection.getParsedTokenAccountsByOwner(vaultPubkey, { mint: skrMint });

        if (accounts.value.length === 0) {
            console.log("âš ï¸ No SKR Token Accounts found for Vault.");
        } else {
            accounts.value.forEach((acc) => {
                const info = acc.account.data.parsed.info;
                console.log(`- Account: ${acc.pubkey.toBase58()}`);
                console.log(`  Balance: ${info.tokenAmount.uiAmountString} SKR`);
            });
        }

    } catch (e: any) {
        console.error("RPC Error:", e.message);
    }
}

investigate();
